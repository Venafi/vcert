// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// PolicyData policy data
//
// swagger:model PolicyData
type PolicyData struct {

	// certificate authority
	CertificateAuthority *LockedValue `json:"CertificateAuthority,omitempty"`

	// csr generation
	CsrGeneration *LockedValue `json:"CsrGeneration,omitempty"`

	// key generation
	KeyGeneration *LockedValue `json:"KeyGeneration,omitempty"`

	// key pair
	KeyPair *KeyPairData `json:"KeyPair,omitempty"`

	// management type
	ManagementType *LockedValue `json:"ManagementType,omitempty"`

	// private key reuse allowed
	PrivateKeyReuseAllowed bool `json:"PrivateKeyReuseAllowed,omitempty"`

	// subj alt name Dns allowed
	SubjAltNameDNSAllowed bool `json:"SubjAltNameDnsAllowed,omitempty"`

	// subj alt name email allowed
	SubjAltNameEmailAllowed bool `json:"SubjAltNameEmailAllowed,omitempty"`

	// subj alt name Ip allowed
	SubjAltNameIPAllowed bool `json:"SubjAltNameIpAllowed,omitempty"`

	// subj alt name upn allowed
	SubjAltNameUpnAllowed bool `json:"SubjAltNameUpnAllowed,omitempty"`

	// subj alt name Uri allowed
	SubjAltNameURIAllowed bool `json:"SubjAltNameUriAllowed,omitempty"`

	// subject
	Subject *SubjectData `json:"Subject,omitempty"`

	// unique subject enforced
	UniqueSubjectEnforced bool `json:"UniqueSubjectEnforced,omitempty"`

	// whitelisted domains
	WhitelistedDomains []string `json:"WhitelistedDomains"`

	// wildcards allowed
	WildcardsAllowed bool `json:"WildcardsAllowed,omitempty"`
}

// Validate validates this policy data
func (m *PolicyData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCertificateAuthority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCsrGeneration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyGeneration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyPair(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubject(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyData) validateCertificateAuthority(formats strfmt.Registry) error {
	if swag.IsZero(m.CertificateAuthority) { // not required
		return nil
	}

	if m.CertificateAuthority != nil {
		if err := m.CertificateAuthority.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CertificateAuthority")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CertificateAuthority")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) validateCsrGeneration(formats strfmt.Registry) error {
	if swag.IsZero(m.CsrGeneration) { // not required
		return nil
	}

	if m.CsrGeneration != nil {
		if err := m.CsrGeneration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CsrGeneration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CsrGeneration")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) validateKeyGeneration(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyGeneration) { // not required
		return nil
	}

	if m.KeyGeneration != nil {
		if err := m.KeyGeneration.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyGeneration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyGeneration")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) validateKeyPair(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyPair) { // not required
		return nil
	}

	if m.KeyPair != nil {
		if err := m.KeyPair.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyPair")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyPair")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) validateManagementType(formats strfmt.Registry) error {
	if swag.IsZero(m.ManagementType) { // not required
		return nil
	}

	if m.ManagementType != nil {
		if err := m.ManagementType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ManagementType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ManagementType")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) validateSubject(formats strfmt.Registry) error {
	if swag.IsZero(m.Subject) { // not required
		return nil
	}

	if m.Subject != nil {
		if err := m.Subject.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Subject")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Subject")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this policy data based on the context it is used
func (m *PolicyData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCertificateAuthority(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCsrGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyGeneration(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyPair(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateManagementType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PolicyData) contextValidateCertificateAuthority(ctx context.Context, formats strfmt.Registry) error {

	if m.CertificateAuthority != nil {
		if err := m.CertificateAuthority.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CertificateAuthority")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CertificateAuthority")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) contextValidateCsrGeneration(ctx context.Context, formats strfmt.Registry) error {

	if m.CsrGeneration != nil {
		if err := m.CsrGeneration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("CsrGeneration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("CsrGeneration")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) contextValidateKeyGeneration(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyGeneration != nil {
		if err := m.KeyGeneration.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyGeneration")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyGeneration")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) contextValidateKeyPair(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyPair != nil {
		if err := m.KeyPair.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyPair")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyPair")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) contextValidateManagementType(ctx context.Context, formats strfmt.Registry) error {

	if m.ManagementType != nil {
		if err := m.ManagementType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ManagementType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ManagementType")
			}
			return err
		}
	}

	return nil
}

func (m *PolicyData) contextValidateSubject(ctx context.Context, formats strfmt.Registry) error {

	if m.Subject != nil {
		if err := m.Subject.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Subject")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Subject")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PolicyData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PolicyData) UnmarshalBinary(b []byte) error {
	var res PolicyData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
